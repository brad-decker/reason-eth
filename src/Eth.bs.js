// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Chain = require("./modules/Chain.bs.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/src/js/promise.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function call(thunk) {
  var val;
  try {
    val = Caml_option.nullable_to_opt(window.ethereum);
  }
  catch (exn){
    return $$Promise.resolved(/* Error */Block.__(1, [/* NotConnectedToProvider */12]));
  }
  if (val !== undefined) {
    return Curry._1(thunk, /* () */0);
  } else {
    return $$Promise.resolved(/* Error */Block.__(1, [/* NotConnectedToProvider */12]));
  }
}

function getChain(param) {
  var val;
  try {
    val = Caml_option.nullable_to_opt(window.ethereum);
  }
  catch (exn){
    return /* NotConnected */6;
  }
  if (val !== undefined) {
    return Chain.fromId(val.chainId);
  } else {
    return /* NotConnected */6;
  }
}

function isMetaMask(param) {
  var val;
  try {
    val = Caml_option.nullable_to_opt(window.ethereum);
  }
  catch (exn){
    return false;
  }
  if (val !== undefined) {
    return val.isMetaMask;
  } else {
    return false;
  }
}

function getStatus(param) {
  var val;
  try {
    val = Caml_option.nullable_to_opt(window.ethereum);
  }
  catch (exn){
    return /* Disconnected */0;
  }
  if (val !== undefined) {
    return /* Connected */1;
  } else {
    return /* Disconnected */0;
  }
}

exports.call = call;
exports.getChain = getChain;
exports.isMetaMask = isMetaMask;
exports.getStatus = getStatus;
/* Promise Not a pure module */
